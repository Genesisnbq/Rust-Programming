# 01_内存 值放堆上还是栈上， 这是一个问题
```rust
fn main() {
    /*
        1. "hello world" 作为一个字符串常量(string literal),
            在编译时被存入可执行文件的 .RODATA段（GCC)或者.RDATA段(VC++),
            在程序加载时，获得一个固定的内存地址
        2.  当执行 "hello world".to_string() 时， 在堆上， 一块新的内存被分配出来，
            并把 "hello world" 逐个字节拷贝过去
        3.  当我们把堆上的数据赋值给s时， s作为分配在栈上的一个变量， 他需要知道堆上的
            内存地址， 另外由于堆上的数据大小不确定且可以增长，我们还需要知道它的长度以及
            它现在有多大
        4.  最终为了表述这个字符串， 我们使用了3个word：第一个表示指针， 第二个表示字符串的当前长度，
            第三个表示这片内存的总容量（11）。在64位的操作系统下，三个word是24个字节
    */
    let _s = "hello world".to_string();
}
```
!["hello world".to_string()](https://static001.geekbang.org/resource/image/cc/c1/cc5ab2b3883befe304340b9385c1fcc1.jpg?wh=1920x2073)

   
        栈是程序运行的基础。每当一个函数被调用时， 一块连续的内存就会在栈顶分配出来，
        这块内存被成为帧（frame)。
        我们知道，栈是自顶向下增长的，一个程序的调用栈最底部，除去入口帧（entry frame），
        就是 main() 函数对应的帧，而随着 main() 函数一层层调用，栈会一层层扩展；
        调用结束，栈又会一层层回溯，把内存释放回去。在调用的过程中，
        一个新的帧会分配足够的空间存储寄存器的上下文。
        在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，
        可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，
        函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来。
    

![栈](https://static001.geekbang.org/resource/image/56/8f/568023dcb61859029aa0eb48c5eb1c8f.jpg?wh=2059x2601)

```rust
    /*
        堆
          栈虽然使用起来高效， 但它的局限也显而易见。 当我们需要动态大小的内存时， 只能使用堆， 比如可变长度的数组，列表，哈希表，字典，
        他们都分配在堆上。
          堆上分配内存时， 一般都会预留一些空间， 这是最佳实践。
        比如你创建一个列表， 并往里添加两个值：
    */
    let mut arr = Vec::new();
    arr.push(1);
    arr.push(2);
        /*
            这个列表实际预留的大小是4， 并不等于其长度2。 这是因为堆上内存分配会使用libc提供的malloc()函数， 其内部会请求操作系统的系统调用， 来分配内存。
        系统调用的代价是昂贵的， 所以我们要避免频繁地 malloc()。

            在堆内存分配时， 预留的空间4 会大于 实际大小2

            除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上
        上面说到，栈上的内存在函数调用结束之后，所使用的帧Frame被回收，相关变量对应的内存
        也都被回收待用。 所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。

            而堆上分配出来的每一块内存需要显示地释放，这就使堆上内存有更加灵活的生命周期，
        可以在不同的调用栈之间共享数据。
    */
```
![堆上内存更加灵活](https://static001.geekbang.org/resource/image/a0/f7/a00687c13a669ac73a0769a0598f4cf7.jpg?wh=1920x1118)
